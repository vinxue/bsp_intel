/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 11:55:35.522641 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file applet_mng_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for AppletMngLoad API */

#include <string.h>
#include "dx_applet_mng_load.h"
#include "applet_mgr_error.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "applet_mng_seprpc.h"


/************ DX_CC_LoadApplet ***************/
DxUint32_t DX_CC_LoadApplet(
	DxUint32_t vrlAddr,
	DxUint32_t magicNum,
	DxUint32_t verKeyIndex,
	DxUint32_t flags,
	DxUint32_t appletImageAddr,
	DxUint32_t userParam)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_DX_CC_LoadAppletParams params;

	/* Verify input parameters and copy into params. struct. */
	params.vrlAddr = cpu_to_le32(vrlAddr);
	params.magicNum = cpu_to_le32(magicNum);
	params.verKeyIndex = cpu_to_le32(verKeyIndex);
	params.flags = cpu_to_le32(flags);
	params.appletImageAddr = cpu_to_le32(appletImageAddr);
	params.userParam = cpu_to_le32(userParam);

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_DX_CC_LoadApplet);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_AppletMngLoad, SEPRPC_FUNC_ID_DX_CC_LoadApplet,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, DX_APP_MNG_ILLEGAL_PARAM_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of DX_CC_LoadApplet failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		case SEPRPC_RET_ENORSC:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		default:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* DX_CC_LoadApplet */



/************ DX_CC_UnloadApplet ***************/
DxUint32_t DX_CC_UnloadApplet(
	DxUint8_t uuid[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_DX_CC_UnloadAppletParams params;

	/* Verify input parameters and copy into params. struct. */
	if (uuid == NULL) {
		params.uuid_null_flag = 1;
	} else {
		memcpy(params.uuid, uuid, sizeof(DxUint8_t) * (sizeof(DX_SepAppUuid_t)));
		params.uuid_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_DX_CC_UnloadApplet);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_AppletMngLoad, SEPRPC_FUNC_ID_DX_CC_UnloadApplet,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, DX_APP_MNG_ILLEGAL_PARAM_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of DX_CC_UnloadApplet failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		case SEPRPC_RET_ENORSC:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		default:
			return DX_APP_MNG_ILLEGAL_PARAM_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* DX_CC_UnloadApplet */


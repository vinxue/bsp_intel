/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 11:54:02.083935 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file crys_aes_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysAes API */

#include <string.h>
#include "crys_aes.h"
#include "crys_aes_error.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_aes_seprpc.h"


/************ CRYS_AES_Wrap ***************/
CRYSError_t CRYS_AES_Wrap(
	DxUint8_t DataIn_ptr[],
	DxUint32_t DataInLen,
	DxUint8_t KeyData[],
	CRYS_AES_KeySize_t KeySize,
	DxInt8_t Reserved,
	DxUint8_t WrapDataOut_ptr[],
	DxUint32_t *WrapDataLen_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_AES_WrapParams params;

	/* Verify input parameters and copy into params. struct. */
	if (DataIn_ptr == NULL) {
		params.DataIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of DataIn_ptr */
		SEP_RPC_ASSERT((DataInLen) <= (CRYS_AES_WRAP_DATA_MAX_SIZE_IN_BYTES), CRYS_AES_WRAP_DATA_LENGTH_ERROR);
		memcpy(params.DataIn_ptr, DataIn_ptr, sizeof(DxUint8_t) * (DataInLen));
		params.DataIn_ptr_null_flag = 0;
	}

	params.DataInLen = cpu_to_le32(DataInLen);
	if (KeyData == NULL) {
		params.KeyData_null_flag = 1;
	} else {
		memcpy(params.KeyData, KeyData, sizeof(DxUint8_t) * (32));
		params.KeyData_null_flag = 0;
	}

	params.KeySize = cpu_to_le32(KeySize);
	params.Reserved = Reserved;
	if (WrapDataLen_ptr == NULL) {
		params.__WrapDataLen_ptr_null_flag = 1;
	} else {
		params.__WrapDataLen_ptr = cpu_to_le32(*(WrapDataLen_ptr));
		params.__WrapDataLen_ptr_null_flag = 0;
	}

	if (WrapDataOut_ptr == NULL) {
		params.WrapDataOut_ptr_null_flag = 1;
    } else if (WrapDataLen_ptr != NULL) {
		/* Verify array size of WrapDataOut_ptr */
		SEP_RPC_ASSERT(((*WrapDataLen_ptr)) <= ((CRYS_AES_WRAP_DATA_MAX_SIZE_IN_BYTES+CRYS_AES_WRAP_BLOCK_SIZE_IN_BYTES)), CRYS_AES_WRAP_DATA_LENGTH_ERROR);
		params.WrapDataOut_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_AES_Wrap);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysAes, SEPRPC_FUNC_ID_CRYS_AES_Wrap,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_AES_UNWRAP_FUNCTION_FAILED_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_AES_Wrap failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_AES_WRAP_DATA_LENGTH_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_AES_WRAP_ILLEGAL_DATA_PTR_ERROR;
		default:
			return CRYS_AES_UNWRAP_FUNCTION_FAILED_ERROR;
		}
	}

	/* Copy back output parameters */
	if (WrapDataLen_ptr == NULL) {
		params.__WrapDataLen_ptr_null_flag = 1;
	} else {
		*(WrapDataLen_ptr) = le32_to_cpu(params.__WrapDataLen_ptr);
		params.__WrapDataLen_ptr_null_flag = 0;
	}

	if (WrapDataOut_ptr == NULL) {
		params.WrapDataOut_ptr_null_flag = 1;
    } else if (WrapDataLen_ptr != NULL) {
		memcpy(WrapDataOut_ptr, params.WrapDataOut_ptr, sizeof(DxUint8_t) * ((*WrapDataLen_ptr)));
		params.WrapDataOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_AES_Wrap */



/************ CRYS_AES_Unwrap ***************/
CRYSError_t CRYS_AES_Unwrap(
	DxUint8_t WrapDataIn_ptr[],
	DxUint32_t WrapDataInLen,
	DxUint8_t KeyData[],
	CRYS_AES_KeySize_t KeySize,
	DxInt8_t Reserved,
	DxUint8_t DataOut_ptr[],
	DxUint32_t *DataOutLen_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_AES_UnwrapParams params;

	/* Verify input parameters and copy into params. struct. */
	if (WrapDataIn_ptr == NULL) {
		params.WrapDataIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of WrapDataIn_ptr */
		SEP_RPC_ASSERT((WrapDataInLen) <= ( (CRYS_AES_WRAP_DATA_MAX_SIZE_IN_BYTES + CRYS_AES_WRAP_BLOCK_SIZE_IN_BYTES)), CRYS_AES_WRAP_DATA_LENGTH_ERROR);
		memcpy(params.WrapDataIn_ptr, WrapDataIn_ptr, sizeof(DxUint8_t) * (WrapDataInLen));
		params.WrapDataIn_ptr_null_flag = 0;
	}

	params.WrapDataInLen = cpu_to_le32(WrapDataInLen);
	if (KeyData == NULL) {
		params.KeyData_null_flag = 1;
	} else {
		memcpy(params.KeyData, KeyData, sizeof(DxUint8_t) * (32));
		params.KeyData_null_flag = 0;
	}

	params.KeySize = cpu_to_le32(KeySize);
	params.Reserved = Reserved;
	if (DataOutLen_ptr == NULL) {
		params.__DataOutLen_ptr_null_flag = 1;
	} else {
		params.__DataOutLen_ptr = cpu_to_le32(*(DataOutLen_ptr));
		params.__DataOutLen_ptr_null_flag = 0;
	}

	if (DataOut_ptr == NULL) {
		params.DataOut_ptr_null_flag = 1;
    } else if (DataOutLen_ptr != NULL) {
		/* Verify array size of DataOut_ptr */
		SEP_RPC_ASSERT(((*DataOutLen_ptr)) <= (CRYS_AES_WRAP_DATA_MAX_SIZE_IN_BYTES), CRYS_AES_WRAP_DATA_LENGTH_ERROR);
		params.DataOut_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_AES_Unwrap);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysAes, SEPRPC_FUNC_ID_CRYS_AES_Unwrap,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_AES_UNWRAP_FUNCTION_FAILED_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_AES_Unwrap failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_AES_WRAP_DATA_LENGTH_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_AES_WRAP_ILLEGAL_DATA_PTR_ERROR;
		default:
			return CRYS_AES_UNWRAP_FUNCTION_FAILED_ERROR;
		}
	}

	/* Copy back output parameters */
	if (DataOutLen_ptr == NULL) {
		params.__DataOutLen_ptr_null_flag = 1;
	} else {
		*(DataOutLen_ptr) = le32_to_cpu(params.__DataOutLen_ptr);
		params.__DataOutLen_ptr_null_flag = 0;
	}

	if (DataOut_ptr == NULL) {
		params.DataOut_ptr_null_flag = 1;
    } else if (DataOutLen_ptr != NULL) {
		memcpy(DataOut_ptr, params.DataOut_ptr, sizeof(DxUint8_t) * ((*DataOutLen_ptr)));
		params.DataOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_AES_Unwrap */


/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 11:56:54.317714 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file crys_rsa_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysRsa API */

#include <string.h>
#include "crys_host_rpc_config.h"
#include "crys_rsa_error.h"
#include "crys_rsa_prim.h"
#include "crys_rsa_schemes.h"
#include "crys_rsa_build.h"
#include "crys_rsa_kg.h"
#include "crys_rsa_extend.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_rsa_seprpc.h"


/************ CRYS_RSA_PRIM_Encrypt ***************/
CRYSError_t CRYS_RSA_PRIM_Encrypt(
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	CRYS_RSAPrimeData_t *PrimeData_ptr,
	DxUint8_t Data_ptr[],
	DxUint16_t DataSize,
	DxUint8_t Output_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_PRIM_EncryptParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr.valid_tag = cpu_to_le32(UserPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				params.__UserPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(UserPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}

	params.PrimeData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrimeData_t)));
	if (Data_ptr == NULL) {
		params.Data_ptr_null_flag = 1;
	} else {
		/* Verify array size of Data_ptr */
		SEP_RPC_ASSERT((DataSize) <= (4*CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Data_ptr, Data_ptr, sizeof(DxUint8_t) * (DataSize));
		params.Data_ptr_null_flag = 0;
	}

	params.DataSize = cpu_to_le16(DataSize);
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else  if (UserPubKey_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT(((((CRYSRSAPubKey_t*)(UserPubKey_ptr->PublicKeyDbBuff))->nSizeInBits)/8) <= (4*CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_PRIM_Encrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_PRIM_Encrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_PRIM_Encrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (UserPubKey_ptr != NULL) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * ((((CRYSRSAPubKey_t*)(UserPubKey_ptr->PublicKeyDbBuff))->nSizeInBits)/8));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_PRIM_Encrypt */



/************ CRYS_RSA_PRIM_Decrypt ***************/
CRYSError_t CRYS_RSA_PRIM_Decrypt(
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAPrimeData_t *PrimeData_ptr,
	DxUint8_t Data_ptr[],
	DxUint16_t DataSize,
	DxUint8_t Output_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_PRIM_DecryptParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1] = cpu_to_le32(UserPrivKey_ptr->PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.PrimeData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrimeData_t)));
	if (Data_ptr == NULL) {
		params.Data_ptr_null_flag = 1;
	} else {
		/* Verify array size of Data_ptr */
		SEP_RPC_ASSERT((DataSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Data_ptr, Data_ptr, sizeof(DxUint8_t) * (DataSize));
		params.Data_ptr_null_flag = 0;
	}

	params.DataSize = cpu_to_le16(DataSize);
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (UserPrivKey_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT(((((CRYSRSAPrivKey_t*)(UserPrivKey_ptr->PrivateKeyDbBuff))->nSizeInBits)/8) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_PRIM_Decrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_PRIM_Decrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_PRIM_Decrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (UserPrivKey_ptr != NULL) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * ((((CRYSRSAPrivKey_t*)(UserPrivKey_ptr->PrivateKeyDbBuff))->nSizeInBits)/8));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_PRIM_Decrypt */



/************ _DX_RSA_SCHEMES_Encrypt ***************/
CRYSError_t _DX_RSA_SCHEMES_Encrypt(
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	CRYS_RSAPrimeData_t *PrimeData_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	DxUint8_t L[],
	DxUint16_t Llen,
	CRYS_PKCS1_MGF_t MGF,
	DxUint8_t DataIn_ptr[],
	DxUint16_t DataInSize,
	DxUint8_t Output_ptr[],
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_SCHEMES_EncryptParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr.valid_tag = cpu_to_le32(UserPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(UserPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}

	params.PrimeData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrimeData_t)));
	params.hashFunc = cpu_to_le32(hashFunc);
	if (L == NULL) {
		params.L_null_flag = 1;
	} else {
		/* Verify array size of L */
		SEP_RPC_ASSERT((Llen) <= (2048), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.L, L, sizeof(DxUint8_t) * (Llen));
		params.L_null_flag = 0;
	}

	params.Llen = cpu_to_le16(Llen);
	params.MGF = cpu_to_le32(MGF);
	if (DataIn_ptr == NULL) {
		params.DataIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of DataIn_ptr */
		SEP_RPC_ASSERT((DataInSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.DataIn_ptr, DataIn_ptr, sizeof(DxUint8_t) * (DataInSize));
		params.DataIn_ptr_null_flag = 0;
	}

	params.DataInSize = cpu_to_le16(DataInSize);
	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (UserPubKey_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT(((((CRYSRSAPubKey_t*)(UserPubKey_ptr->PublicKeyDbBuff))->nSizeInBits)/8) <= (4*CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_SCHEMES_Encrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_SCHEMES_Encrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_SCHEMES_Encrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (UserPubKey_ptr != NULL) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * ((((CRYSRSAPubKey_t*)(UserPubKey_ptr->PublicKeyDbBuff))->nSizeInBits)/8));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_SCHEMES_Encrypt */



/************ _DX_RSA_SCHEMES_Decrypt ***************/
CRYSError_t _DX_RSA_SCHEMES_Decrypt(
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAPrimeData_t *PrimeData_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	DxUint8_t L[],
	DxUint16_t Llen,
	CRYS_PKCS1_MGF_t MGF,
	DxUint8_t DataIn_ptr[],
	DxUint16_t DataInSize,
	DxUint8_t Output_ptr[],
	DxUint16_t *OutputSize_ptr,
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_SCHEMES_DecryptParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1] = cpu_to_le32(UserPrivKey_ptr->PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.PrimeData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrimeData_t)));
	params.hashFunc = cpu_to_le32(hashFunc);
	if (L == NULL) {
		params.L_null_flag = 1;
	} else {
		/* Verify array size of L */
		SEP_RPC_ASSERT((Llen) <= (2048), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.L, L, sizeof(DxUint8_t) * (Llen));
		params.L_null_flag = 0;
	}

	params.Llen = cpu_to_le16(Llen);
	params.MGF = cpu_to_le32(MGF);
	if (DataIn_ptr == NULL) {
		params.DataIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of DataIn_ptr */
		SEP_RPC_ASSERT((DataInSize) <= (4*CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.DataIn_ptr, DataIn_ptr, sizeof(DxUint8_t) * (DataInSize));
		params.DataIn_ptr_null_flag = 0;
	}

	params.DataInSize = cpu_to_le16(DataInSize);
	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);
	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		params.__OutputSize_ptr = cpu_to_le16(*(OutputSize_ptr));
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT((*OutputSize_ptr) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_SCHEMES_Decrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_SCHEMES_Decrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_SCHEMES_Decrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		*(OutputSize_ptr) = le16_to_cpu(params.__OutputSize_ptr);
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL && (*OutputSize_ptr <= (sizeof(params.Output_ptr) / sizeof(params.Output_ptr[0])))) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * (*OutputSize_ptr));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_SCHEMES_Decrypt */



/************ _DX_RSA_SignInit ***************/
CRYSError_t _DX_RSA_SignInit(
	CRYS_RSAPrivUserContext_t *UserContext_ptr,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	CRYS_PKCS1_MGF_t MGF,
	DxUint16_t SaltLen,
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_SignInitParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1] = cpu_to_le32(UserPrivKey_ptr->PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.hashFunc = cpu_to_le32(hashFunc);
	params.MGF = cpu_to_le32(MGF);
	params.SaltLen = cpu_to_le16(SaltLen);
	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr.valid_tag = cpu_to_le32(UserContext_ptr->valid_tag);
		params.__UserContext_ptr.AES_iv = cpu_to_le32(UserContext_ptr->AES_iv);
		/* Verify array size of context_buff */
		SEP_RPC_ASSERT((sizeof(RSAPrivContext_t) + 1) <= (sizeof(RSAPrivContext_t)+ 1), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__UserContext_ptr.context_buff, UserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t) + 1));
		params.__UserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_SignInit);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_SignInit,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_SignInit failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		memcpy(UserContext_ptr->context_buff, params.__UserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t) + 1));
		params.__UserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_SignInit */



/************ _DX_RSA_SignFinish ***************/
CRYSError_t _DX_RSA_SignFinish(
	CRYS_RSAPrivUserContext_t *UserContext_ptr,
	DxUint8_t Output_ptr[],
	DxUint16_t *OutputSize_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_SignFinishParams params;

	/* Verify input parameters and copy into params. struct. */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr.valid_tag = cpu_to_le32(UserContext_ptr->valid_tag);
		params.__UserContext_ptr.AES_iv = cpu_to_le32(UserContext_ptr->AES_iv);
		memcpy(params.__UserContext_ptr.context_buff, UserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t) + 1));
		params.__UserContext_ptr_null_flag = 0;
	}

	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		params.__OutputSize_ptr = cpu_to_le16(*(OutputSize_ptr));
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT((*OutputSize_ptr) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_SignFinish);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_SignFinish,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_SignFinish failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		memcpy(UserContext_ptr->context_buff, params.__UserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t) + 1));
		params.__UserContext_ptr_null_flag = 0;
	}

	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		*(OutputSize_ptr) = le16_to_cpu(params.__OutputSize_ptr);
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL && (*OutputSize_ptr <= (sizeof(params.Output_ptr) / sizeof(params.Output_ptr[0])))) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * (*OutputSize_ptr));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_SignFinish */



/************ _DX_RSA_SignUpdate ***************/
CRYSError_t _DX_RSA_SignUpdate(
	CRYS_RSAPrivUserContext_t *UserContext_ptr,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM__DX_RSA_SignUpdate];
	struct SepRpc__DX_RSA_SignUpdateParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DataInSize = cpu_to_le32(DataInSize);
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr.valid_tag = cpu_to_le32(UserContext_ptr->valid_tag);
		params.__UserContext_ptr.AES_iv = cpu_to_le32(UserContext_ptr->AES_iv);
		memcpy(params.__UserContext_ptr.context_buff, UserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t)+ 1));
		params.__UserContext_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_SignUpdate);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_SignUpdate,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_SignUpdate failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		memcpy(UserContext_ptr->context_buff, params.__UserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(RSAPrivContext_t)+ 1));
		params.__UserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_SignUpdate */



/************ _DX_RSA_Sign ***************/
CRYSError_t _DX_RSA_Sign(
	CRYS_RSAPrivUserContext_t *UserContext_ptr,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	CRYS_PKCS1_MGF_t MGF,
	DxUint16_t SaltLen,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize,
	DxUint8_t Output_ptr[],
	DxUint16_t *OutputSize_ptr,
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM__DX_RSA_Sign];
	struct SepRpc__DX_RSA_SignParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	params.UserContext_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrivUserContext_t)));
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1] = cpu_to_le32(UserPrivKey_ptr->PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.hashFunc = cpu_to_le32(hashFunc);
	params.MGF = cpu_to_le32(MGF);
	params.SaltLen = cpu_to_le16(SaltLen);
	params.DataInSize = cpu_to_le32(DataInSize);
	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);
	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		params.__OutputSize_ptr = cpu_to_le16(*(OutputSize_ptr));
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL) {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT((*OutputSize_ptr) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_Sign);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_Sign,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_Sign failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (OutputSize_ptr == NULL) {
		params.__OutputSize_ptr_null_flag = 1;
	} else {
		*(OutputSize_ptr) = le16_to_cpu(params.__OutputSize_ptr);
		params.__OutputSize_ptr_null_flag = 0;
	}

	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (OutputSize_ptr != NULL && (*OutputSize_ptr <= (sizeof(params.Output_ptr) / sizeof(params.Output_ptr[0])))) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * (*OutputSize_ptr));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_Sign */



/************ _DX_RSA_VerifyInit ***************/
CRYSError_t _DX_RSA_VerifyInit(
	CRYS_RSAPubUserContext_t *UserContext_ptr,
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	CRYS_PKCS1_MGF_t MGF,
	DxUint16_t SaltLen,
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_VerifyInitParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr.valid_tag = cpu_to_le32(UserPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(UserPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}

	params.hashFunc = cpu_to_le32(hashFunc);
	params.MGF = cpu_to_le32(MGF);
	params.SaltLen = cpu_to_le16(SaltLen);
	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_VerifyInit);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_VerifyInit,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_VerifyInit failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		for (i1 = 0; i1 < (sizeof(RSAPubContext_t)/sizeof(DxUint32_t) + 1); i1++) {
				UserContext_ptr->context_buff[i1] = le32_to_cpu(params.__UserContext_ptr.context_buff[i1]);
		}
		params.__UserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_VerifyInit */



/************ _DX_RSA_VerifyUpdate ***************/
CRYSError_t _DX_RSA_VerifyUpdate(
	CRYS_RSAPubUserContext_t *UserContext_ptr,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM__DX_RSA_VerifyUpdate];
	struct SepRpc__DX_RSA_VerifyUpdateParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	params.DataInSize = cpu_to_le32(DataInSize);
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr.valid_tag = cpu_to_le32(UserContext_ptr->valid_tag);
		params.__UserContext_ptr.AES_iv = cpu_to_le32(UserContext_ptr->AES_iv);
		for (i1 = 0; i1 < (sizeof(RSAPubContext_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserContext_ptr.context_buff[i1] = cpu_to_le32(UserContext_ptr->context_buff[i1]);
		}
		params.__UserContext_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_VerifyUpdate);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_VerifyUpdate,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_VerifyUpdate failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		for (i1 = 0; i1 < (sizeof(RSAPubContext_t)/sizeof(DxUint32_t) + 1); i1++) {
				UserContext_ptr->context_buff[i1] = le32_to_cpu(params.__UserContext_ptr.context_buff[i1]);
		}
		params.__UserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_VerifyUpdate */



/************ _DX_RSA_VerifyFinish ***************/
CRYSError_t _DX_RSA_VerifyFinish(
	CRYS_RSAPubUserContext_t *UserContext_ptr,
	DxUint8_t Sig_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_RSA_VerifyFinishParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (Sig_ptr == NULL) {
		params.Sig_ptr_null_flag = 1;
	} else {
		/* Verify array size of Sig_ptr */
		SEP_RPC_ASSERT((((RSAPubContext_t*)UserContext_ptr->context_buff)->nSizeInBytes) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Sig_ptr, Sig_ptr, sizeof(DxUint8_t) * (((RSAPubContext_t*)UserContext_ptr->context_buff)->nSizeInBytes));
		params.Sig_ptr_null_flag = 0;
	}

	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		params.__UserContext_ptr.valid_tag = cpu_to_le32(UserContext_ptr->valid_tag);
		params.__UserContext_ptr.AES_iv = cpu_to_le32(UserContext_ptr->AES_iv);
		for (i1 = 0; i1 < (sizeof(RSAPubContext_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserContext_ptr.context_buff[i1] = cpu_to_le32(UserContext_ptr->context_buff[i1]);
		}
		params.__UserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_VerifyFinish);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_VerifyFinish,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_VerifyFinish failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserContext_ptr == NULL) {
		params.__UserContext_ptr_null_flag = 1;
	} else {
		UserContext_ptr->valid_tag = le32_to_cpu(params.__UserContext_ptr.valid_tag);
		UserContext_ptr->AES_iv = le32_to_cpu(params.__UserContext_ptr.AES_iv);
		for (i1 = 0; i1 < (sizeof(RSAPubContext_t)/sizeof(DxUint32_t) + 1); i1++) {
				UserContext_ptr->context_buff[i1] = le32_to_cpu(params.__UserContext_ptr.context_buff[i1]);
		}
		params.__UserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_VerifyFinish */



/************ _DX_RSA_Verify ***************/
CRYSError_t _DX_RSA_Verify(
	CRYS_RSAPubUserContext_t *UserContext_ptr,
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	CRYS_RSA_HASH_OpMode_t hashFunc,
	CRYS_PKCS1_MGF_t MGF,
	DxUint16_t SaltLen,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize,
	DxUint8_t Sig_ptr[],
	CRYS_PKCS1_version PKCS1_ver)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM__DX_RSA_Verify];
	struct SepRpc__DX_RSA_VerifyParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	params.UserContext_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPubUserContext_t)));
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr.valid_tag = cpu_to_le32(UserPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				params.__UserPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(UserPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}

	params.hashFunc = cpu_to_le32(hashFunc);
	params.MGF = cpu_to_le32(MGF);
	params.SaltLen = cpu_to_le16(SaltLen);
	params.DataInSize = cpu_to_le32(DataInSize);
	if (Sig_ptr == NULL) {
		params.Sig_ptr_null_flag = 1;
    } else if (UserPubKey_ptr != NULL) {
		/* Verify array size of Sig_ptr */
		SEP_RPC_ASSERT(((((CRYSRSAPubKey_t*)UserPubKey_ptr->PublicKeyDbBuff)->nSizeInBits+7)/8) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Sig_ptr, Sig_ptr, sizeof(DxUint8_t) * ((((CRYSRSAPubKey_t*)UserPubKey_ptr->PublicKeyDbBuff)->nSizeInBits+7)/8));
		params.Sig_ptr_null_flag = 0;
	}

	params.PKCS1_ver = cpu_to_le32(PKCS1_ver);

	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_RSA_Verify);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID__DX_RSA_Verify,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_RSA_Verify failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* _DX_RSA_Verify */



/************ CRYS_RSA_Build_PubKey ***************/
CRYSError_t CRYS_RSA_Build_PubKey(
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	DxUint8_t Exponent_ptr[],
	DxUint16_t ExponentSize,
	DxUint8_t Modulus_ptr[],
	DxUint16_t ModulusSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_Build_PubKeyParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (Exponent_ptr == NULL) {
		params.Exponent_ptr_null_flag = 1;
	} else {
		/* Verify array size of Exponent_ptr */
		SEP_RPC_ASSERT((ExponentSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Exponent_ptr, Exponent_ptr, sizeof(DxUint8_t) * (ExponentSize));
		params.Exponent_ptr_null_flag = 0;
	}

	params.ExponentSize = cpu_to_le16(ExponentSize);
	if (Modulus_ptr == NULL) {
		params.Modulus_ptr_null_flag = 1;
	} else {
		/* Verify array size of Modulus_ptr */
		SEP_RPC_ASSERT((ModulusSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Modulus_ptr, Modulus_ptr, sizeof(DxUint8_t) * (ModulusSize));
		params.Modulus_ptr_null_flag = 0;
	}

	params.ModulusSize = cpu_to_le16(ModulusSize);
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_Build_PubKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_Build_PubKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_Build_PubKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		UserPubKey_ptr->valid_tag = le32_to_cpu(params.__UserPubKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				UserPubKey_ptr->PublicKeyDbBuff[i1] = le32_to_cpu(params.__UserPubKey_ptr.PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_Build_PubKey */



/************ CRYS_RSA_Build_PrivKey ***************/
CRYSError_t CRYS_RSA_Build_PrivKey(
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	DxUint8_t PrivExponent_ptr[],
	DxUint16_t PrivExponentSize,
	DxUint8_t PubExponent_ptr[],
	DxUint16_t PubExponentSize,
	DxUint8_t Modulus_ptr[],
	DxUint16_t ModulusSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_Build_PrivKeyParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (PrivExponent_ptr == NULL) {
		params.PrivExponent_ptr_null_flag = 1;
	} else {
		/* Verify array size of PrivExponent_ptr */
		SEP_RPC_ASSERT((PrivExponentSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.PrivExponent_ptr, PrivExponent_ptr, sizeof(DxUint8_t) * (PrivExponentSize));
		params.PrivExponent_ptr_null_flag = 0;
	}

	params.PrivExponentSize = cpu_to_le16(PrivExponentSize);
	if (PubExponent_ptr == NULL) {
		params.PubExponent_ptr_null_flag = 1;
	} else {
		/* Verify array size of PubExponent_ptr */
		SEP_RPC_ASSERT((PubExponentSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.PubExponent_ptr, PubExponent_ptr, sizeof(DxUint8_t) * (PubExponentSize));
		params.PubExponent_ptr_null_flag = 0;
	}

	params.PubExponentSize = cpu_to_le16(PubExponentSize);
	if (Modulus_ptr == NULL) {
		params.Modulus_ptr_null_flag = 1;
	} else {
		/* Verify array size of Modulus_ptr */
		SEP_RPC_ASSERT((ModulusSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Modulus_ptr, Modulus_ptr, sizeof(DxUint8_t) * (ModulusSize));
		params.Modulus_ptr_null_flag = 0;
	}

	params.ModulusSize = cpu_to_le16(ModulusSize);
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_Build_PrivKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_Build_PrivKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_Build_PrivKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_Build_PrivKey */



/************ CRYS_RSA_Build_PrivKeyCRT ***************/
CRYSError_t CRYS_RSA_Build_PrivKeyCRT(
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	DxUint8_t P_ptr[],
	DxUint16_t PSize,
	DxUint8_t Q_ptr[],
	DxUint16_t QSize,
	DxUint8_t dP_ptr[],
	DxUint16_t dPSize,
	DxUint8_t dQ_ptr[],
	DxUint16_t dQSize,
	DxUint8_t qInv_ptr[],
	DxUint16_t qInvSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_Build_PrivKeyCRTParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (P_ptr == NULL) {
		params.P_ptr_null_flag = 1;
	} else {
		/* Verify array size of P_ptr */
		SEP_RPC_ASSERT((PSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.P_ptr, P_ptr, sizeof(DxUint8_t) * (PSize));
		params.P_ptr_null_flag = 0;
	}

	params.PSize = cpu_to_le16(PSize);
	if (Q_ptr == NULL) {
		params.Q_ptr_null_flag = 1;
	} else {
		/* Verify array size of Q_ptr */
		SEP_RPC_ASSERT((PSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.Q_ptr, Q_ptr, sizeof(DxUint8_t) * (PSize));
		params.Q_ptr_null_flag = 0;
	}

	params.QSize = cpu_to_le16(QSize);
	if (dP_ptr == NULL) {
		params.dP_ptr_null_flag = 1;
	} else {
		/* Verify array size of dP_ptr */
		SEP_RPC_ASSERT((PSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.dP_ptr, dP_ptr, sizeof(DxUint8_t) * (PSize));
		params.dP_ptr_null_flag = 0;
	}

	params.dPSize = cpu_to_le16(dPSize);
	if (dQ_ptr == NULL) {
		params.dQ_ptr_null_flag = 1;
	} else {
		/* Verify array size of dQ_ptr */
		SEP_RPC_ASSERT((PSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.dQ_ptr, dQ_ptr, sizeof(DxUint8_t) * (PSize));
		params.dQ_ptr_null_flag = 0;
	}

	params.dQSize = cpu_to_le16(dQSize);
	if (qInv_ptr == NULL) {
		params.qInv_ptr_null_flag = 1;
	} else {
		/* Verify array size of qInv_ptr */
		SEP_RPC_ASSERT((PSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.qInv_ptr, qInv_ptr, sizeof(DxUint8_t) * (PSize));
		params.qInv_ptr_null_flag = 0;
	}

	params.qInvSize = cpu_to_le16(qInvSize);
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_Build_PrivKeyCRT);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_Build_PrivKeyCRT,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_Build_PrivKeyCRT failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_Build_PrivKeyCRT */



/************ CRYS_RSA_KG_GenerateKeyPair ***************/
CRYSError_t CRYS_RSA_KG_GenerateKeyPair(
	DxUint8_t pubExp_ptr[],
	DxUint16_t pubExpSizeInBytes,
	DxUint32_t keySize,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAUserPubKey_t *userPubKey_ptr,
	CRYS_RSAKGData_t *keyGenData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_KG_GenerateKeyPairParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (pubExp_ptr == NULL) {
		params.pubExp_ptr_null_flag = 1;
	} else {
		/* Verify array size of pubExp_ptr */
		SEP_RPC_ASSERT((pubExpSizeInBytes) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.pubExp_ptr, pubExp_ptr, sizeof(DxUint8_t) * (pubExpSizeInBytes));
		params.pubExp_ptr_null_flag = 0;
	}

	params.pubExpSizeInBytes = cpu_to_le16(pubExpSizeInBytes);
	params.keySize = cpu_to_le32(keySize);
	params.keyGenData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAKGData_t)));
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		params.__userPubKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_KG_GenerateKeyPair);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_KG_GenerateKeyPair,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_KG_GenerateKeyPair failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		userPubKey_ptr->valid_tag = le32_to_cpu(params.__userPubKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				userPubKey_ptr->PublicKeyDbBuff[i1] = le32_to_cpu(params.__userPubKey_ptr.PublicKeyDbBuff[i1]);
		}
		params.__userPubKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_KG_GenerateKeyPair */



/************ CRYS_RSA_KG_GenerateKeyPairCRT ***************/
CRYSError_t CRYS_RSA_KG_GenerateKeyPairCRT(
	DxUint8_t pubExp_ptr[],
	DxUint16_t pubExpSizeInBytes,
	DxUint32_t keySize,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAUserPubKey_t *userPubKey_ptr,
	CRYS_RSAKGData_t *keyGenData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_KG_GenerateKeyPairCRTParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (pubExp_ptr == NULL) {
		params.pubExp_ptr_null_flag = 1;
	} else {
		/* Verify array size of pubExp_ptr */
		SEP_RPC_ASSERT((pubExpSizeInBytes) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4*2+1), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.pubExp_ptr, pubExp_ptr, sizeof(DxUint8_t) * (pubExpSizeInBytes));
		params.pubExp_ptr_null_flag = 0;
	}

	params.pubExpSizeInBytes = cpu_to_le16(pubExpSizeInBytes);
	params.keySize = cpu_to_le32(keySize);
	params.keyGenData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAKGData_t)));
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		params.__userPubKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_KG_GenerateKeyPairCRT);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_KG_GenerateKeyPairCRT,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_KG_GenerateKeyPairCRT failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		userPubKey_ptr->valid_tag = le32_to_cpu(params.__userPubKey_ptr.valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				userPubKey_ptr->PublicKeyDbBuff[i1] = le32_to_cpu(params.__userPubKey_ptr.PublicKeyDbBuff[i1]);
		}
		params.__userPubKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_KG_GenerateKeyPairCRT */



/************ CRYS_RSA_Get_PubKey ***************/
CRYSError_t CRYS_RSA_Get_PubKey(
	CRYS_RSAUserPubKey_t *UserPubKey_ptr,
	DxUint8_t Exponent_ptr[],
	DxUint16_t *ExponentSize_ptr,
	DxUint8_t Modulus_ptr[],
	DxUint16_t *ModulusSize_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_Get_PubKeyParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPubKey_ptr == NULL) {
		params.__UserPubKey_ptr_null_flag = 1;
	} else {
		params.__UserPubKey_ptr.valid_tag = cpu_to_le32(UserPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				params.__UserPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(UserPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__UserPubKey_ptr_null_flag = 0;
	}

	if (ExponentSize_ptr == NULL) {
		params.__ExponentSize_ptr_null_flag = 1;
	} else {
		params.__ExponentSize_ptr = cpu_to_le16(*(ExponentSize_ptr));
		params.__ExponentSize_ptr_null_flag = 0;
	}

	if (ModulusSize_ptr == NULL) {
		params.__ModulusSize_ptr_null_flag = 1;
	} else {
		params.__ModulusSize_ptr = cpu_to_le16(*(ModulusSize_ptr));
		params.__ModulusSize_ptr_null_flag = 0;
	}

	if (Exponent_ptr == NULL) {
		params.Exponent_ptr_null_flag = 1;
    } else if (ExponentSize_ptr != NULL) {
		/* Verify array size of Exponent_ptr */
		SEP_RPC_ASSERT((*ExponentSize_ptr) <= ( CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4-1), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Exponent_ptr_null_flag = 0;
	}

	if (Modulus_ptr == NULL) {
		params.Modulus_ptr_null_flag = 1;
    } else if (ModulusSize_ptr != NULL) {
		/* Verify array size of Modulus_ptr */
		SEP_RPC_ASSERT((*ModulusSize_ptr) <= ( CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4-1), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Modulus_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_Get_PubKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_Get_PubKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_Get_PubKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (ExponentSize_ptr == NULL) {
		params.__ExponentSize_ptr_null_flag = 1;
	} else {
		*(ExponentSize_ptr) = le16_to_cpu(params.__ExponentSize_ptr);
		params.__ExponentSize_ptr_null_flag = 0;
	}

	if (ModulusSize_ptr == NULL) {
		params.__ModulusSize_ptr_null_flag = 1;
	} else {
		*(ModulusSize_ptr) = le16_to_cpu(params.__ModulusSize_ptr);
		params.__ModulusSize_ptr_null_flag = 0;
	}

	if (Exponent_ptr == NULL) {
		params.Exponent_ptr_null_flag = 1;
    } else if (ExponentSize_ptr != NULL && (*ExponentSize_ptr <= (sizeof(params.Exponent_ptr) / sizeof(params.Exponent_ptr[0])))) {
		memcpy(Exponent_ptr, params.Exponent_ptr, sizeof(DxUint8_t) * (*ExponentSize_ptr));
		params.Exponent_ptr_null_flag = 0;
	}

	if (Modulus_ptr == NULL) {
		params.Modulus_ptr_null_flag = 1;
    } else if (ModulusSize_ptr != NULL && (*ModulusSize_ptr <= (sizeof(params.Modulus_ptr) / sizeof(params.Modulus_ptr[0])))) {
		memcpy(Modulus_ptr, params.Modulus_ptr, sizeof(DxUint8_t) * (*ModulusSize_ptr));
		params.Modulus_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_Get_PubKey */



/************ CRYS_RSA_Get_ModSizeFromPubKey ***************/
CRYSError_t CRYS_RSA_Get_ModSizeFromPubKey(
	CRYS_RSAUserPubKey_t *userPubKey_ptr,
	DxUint16_t *ModulusSize_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_Get_ModSizeFromPubKeyParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		params.__userPubKey_ptr.valid_tag = cpu_to_le32(userPubKey_ptr->valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				params.__userPubKey_ptr.PublicKeyDbBuff[i1] = cpu_to_le32(userPubKey_ptr->PublicKeyDbBuff[i1]);
		}
		params.__userPubKey_ptr_null_flag = 0;
	}

	if (ModulusSize_ptr == NULL) {
		params.__ModulusSize_ptr_null_flag = 1;
	} else {
		params.__ModulusSize_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_Get_ModSizeFromPubKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_Get_ModSizeFromPubKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_Get_ModSizeFromPubKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (ModulusSize_ptr == NULL) {
		params.__ModulusSize_ptr_null_flag = 1;
	} else {
		*(ModulusSize_ptr) = le16_to_cpu(params.__ModulusSize_ptr);
		params.__ModulusSize_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_Get_ModSizeFromPubKey */



/************ CRYS_RSA_PRIM_DecryptExactSize ***************/
CRYSError_t CRYS_RSA_PRIM_DecryptExactSize(
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAPrimeData_t *PrimeData_ptr,
	DxUint8_t DataIn_ptr[],
	DxUint8_t Output_ptr[],
	DxUint16_t DataOutSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_PRIM_DecryptExactSizeParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1] = cpu_to_le32(UserPrivKey_ptr->PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.PrimeData_ptr_size = cpu_to_le32((sizeof(CRYS_RSAPrimeData_t)));
	if (DataIn_ptr == NULL) {
		params.DataIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of DataIn_ptr */
		SEP_RPC_ASSERT((DataOutSize) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.DataIn_ptr, DataIn_ptr, sizeof(DxUint8_t) * (DataOutSize));
		params.DataIn_ptr_null_flag = 0;
	}

	params.DataOutSize = cpu_to_le16(DataOutSize);
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
	} else {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT((DataOutSize) <= (4*CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_PRIM_DecryptExactSize);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_PRIM_DecryptExactSize,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_PRIM_DecryptExactSize failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (DataOutSize <= (sizeof(params.Output_ptr) / sizeof(params.Output_ptr[0]))) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * (DataOutSize));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_PRIM_DecryptExactSize */



/************ CRYS_RSA_InvModWord ***************/
CRYSError_t CRYS_RSA_InvModWord(
	DxUint32_t aVal,
	DxUint32_t modVal,
	DxUint32_t *invMod_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_InvModWordParams params;

	/* Verify input parameters and copy into params. struct. */
	params.aVal = cpu_to_le32(aVal);
	params.modVal = cpu_to_le32(modVal);
	if (invMod_ptr == NULL) {
		params.__invMod_ptr_null_flag = 1;
	} else {
		params.__invMod_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_InvModWord);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_InvModWord,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_InvModWord failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (invMod_ptr == NULL) {
		params.__invMod_ptr_null_flag = 1;
	} else {
		*(invMod_ptr) = le32_to_cpu(params.__invMod_ptr);
		params.__invMod_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_InvModWord */



/************ CRYS_RSA_KG_GeneratePQprimes ***************/
CRYSError_t CRYS_RSA_KG_GeneratePQprimes(
	DxUint8_t pubExp_ptr[],
	DxUint16_t pubExpSizeInBytes,
	DxUint32_t primeSizeInBits,
	DxUint32_t testsCount,
	DxUint32_t p_ptr[],
	DxUint32_t q_ptr[],
	CRYS_RSAKGData_t *keyGenData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_KG_GeneratePQprimesParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (pubExp_ptr == NULL) {
		params.pubExp_ptr_null_flag = 1;
	} else {
		/* Verify array size of pubExp_ptr */
		SEP_RPC_ASSERT((pubExpSizeInBytes) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4*2+1), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.pubExp_ptr, pubExp_ptr, sizeof(DxUint8_t) * (pubExpSizeInBytes));
		params.pubExp_ptr_null_flag = 0;
	}

	params.pubExpSizeInBytes = cpu_to_le16(pubExpSizeInBytes);
	params.primeSizeInBits = cpu_to_le32(primeSizeInBits);
	params.testsCount = cpu_to_le32(testsCount);
	if (keyGenData_ptr == NULL) {
		params.__keyGenData_ptr_null_flag = 1;
	} else {
		params.__keyGenData_ptr = *(keyGenData_ptr);
		params.__keyGenData_ptr_null_flag = 0;
	}

	if (p_ptr == NULL) {
		params.p_ptr_null_flag = 1;
	} else {
		/* Verify array size of p_ptr */
		SEP_RPC_ASSERT((primeSizeInBits/32) <= ((CRYS_PKA_MAX_KEY_GENERATION_SIZE_BITS/32)/2), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.p_ptr_null_flag = 0;
	}

	if (q_ptr == NULL) {
		params.q_ptr_null_flag = 1;
	} else {
		/* Verify array size of q_ptr */
		SEP_RPC_ASSERT((primeSizeInBits/32) <= ((CRYS_PKA_MAX_KEY_GENERATION_SIZE_BITS/32)/2), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.q_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_KG_GeneratePQprimes);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_KG_GeneratePQprimes,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_KG_GeneratePQprimes failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (p_ptr == NULL) {
		params.p_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (primeSizeInBits/32); i1++) {
				p_ptr[i1] = le32_to_cpu(params.p_ptr[i1]);
		}
		params.p_ptr_null_flag = 0;
	}

	if (q_ptr == NULL) {
		params.q_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (primeSizeInBits/32); i1++) {
				q_ptr[i1] = le32_to_cpu(params.q_ptr[i1]);
		}
		params.q_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_KG_GeneratePQprimes */



/************ CRYS_RSA_KG_CalculateKeyPairFromPQ ***************/
CRYSError_t CRYS_RSA_KG_CalculateKeyPairFromPQ(
	DxUint8_t pubExp_ptr[],
	DxUint16_t pubExpSizeInBytes,
	DxUint32_t p_ptr[],
	DxUint32_t q_ptr[],
	DxUint16_t primeSizeInBits,
	CRYS_RSA_DecryptionMode_t privKeyMode,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAUserPubKey_t *userPubKey_ptr,
	CRYS_RSAKGData_t *keyGenData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RSA_KG_CalculateKeyPairFromPQParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (pubExp_ptr == NULL) {
		params.pubExp_ptr_null_flag = 1;
	} else {
		/* Verify array size of pubExp_ptr */
		SEP_RPC_ASSERT((pubExpSizeInBytes) <= ( CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.pubExp_ptr, pubExp_ptr, sizeof(DxUint8_t) * (pubExpSizeInBytes));
		params.pubExp_ptr_null_flag = 0;
	}

	params.pubExpSizeInBytes = cpu_to_le16(pubExpSizeInBytes);
	if (p_ptr == NULL) {
		params.p_ptr_null_flag = 1;
	} else {
		/* Verify array size of p_ptr */
		SEP_RPC_ASSERT((primeSizeInBits/32) <= ((CRYS_PKA_MAX_KEY_GENERATION_SIZE_BITS/32)/2), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		for (i1 = 0; i1 < (primeSizeInBits/32); i1++) {
				params.p_ptr[i1] = cpu_to_le32(p_ptr[i1]);
		}
		params.p_ptr_null_flag = 0;
	}

	if (q_ptr == NULL) {
		params.q_ptr_null_flag = 1;
	} else {
		/* Verify array size of q_ptr */
		SEP_RPC_ASSERT((primeSizeInBits/32) <= ((CRYS_PKA_MAX_KEY_GENERATION_SIZE_BITS/32)/2), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		for (i1 = 0; i1 < (primeSizeInBits/32); i1++) {
				params.q_ptr[i1] = cpu_to_le32(q_ptr[i1]);
		}
		params.q_ptr_null_flag = 0;
	}

	params.primeSizeInBits = cpu_to_le16(primeSizeInBits);
	params.privKeyMode = cpu_to_le32(privKeyMode);
	if (keyGenData_ptr == NULL) {
		params.__keyGenData_ptr_null_flag = 1;
	} else {
		params.__keyGenData_ptr = *(keyGenData_ptr);
		params.__keyGenData_ptr_null_flag = 0;
	}

	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		params.__userPubKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RSA_KG_CalculateKeyPairFromPQ);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_CRYS_RSA_KG_CalculateKeyPairFromPQ,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RSA_KG_CalculateKeyPairFromPQ failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < (sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		userPubKey_ptr->valid_tag = le32_to_cpu(params.__userPubKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				userPubKey_ptr->PublicKeyDbBuff[i1] = le32_to_cpu(params.__userPubKey_ptr.PublicKeyDbBuff[i1]);
		}
		params.__userPubKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RSA_KG_CalculateKeyPairFromPQ */



/************ DX_RSA_KG_ExtendGenerateKeyPair ***************/
CRYSError_t DX_RSA_KG_ExtendGenerateKeyPair(
	DxUint8_t pubExp_ptr[],
	DxUint16_t pubExpSizeInBytes,
	DxUint32_t keySizeBits,
	CRYS_RSA_DecryptionMode_t privKeyMode,
	CRYS_RSAUserPrivKey_t *UserPrivKey_ptr,
	CRYS_RSAUserPubKey_t *userPubKey_ptr,
	CRYS_RSAKGData_t *keyGenData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_DX_RSA_KG_ExtendGenerateKeyPairParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (pubExp_ptr == NULL) {
		params.pubExp_ptr_null_flag = 1;
	} else {
		/* Verify array size of pubExp_ptr */
		SEP_RPC_ASSERT((pubExpSizeInBytes) <= (CRYS_RSA_MAXIMUM_MOD_BUFFER_SIZE_IN_WORDS*4), CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.pubExp_ptr, pubExp_ptr, sizeof(DxUint8_t) * (pubExpSizeInBytes));
		params.pubExp_ptr_null_flag = 0;
	}

	params.pubExpSizeInBytes = cpu_to_le16(pubExpSizeInBytes);
	params.keySizeBits = cpu_to_le32(keySizeBits);
	params.privKeyMode = cpu_to_le32(privKeyMode);
	if (keyGenData_ptr == NULL) {
		params.__keyGenData_ptr_null_flag = 1;
	} else {
		params.__keyGenData_ptr = *(keyGenData_ptr);
		params.__keyGenData_ptr_null_flag = 0;
	}

	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		params.__userPubKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_DX_RSA_KG_ExtendGenerateKeyPair);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRsa, SEPRPC_FUNC_ID_DX_RSA_KG_ExtendGenerateKeyPair,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of DX_RSA_KG_ExtendGenerateKeyPair failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_RSA_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPrivKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				UserPrivKey_ptr->PrivateKeyDbBuff[i1] = le32_to_cpu(params.__UserPrivKey_ptr.PrivateKeyDbBuff[i1]);
		}
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (userPubKey_ptr == NULL) {
		params.__userPubKey_ptr_null_flag = 1;
	} else {
		userPubKey_ptr->valid_tag = le32_to_cpu(params.__userPubKey_ptr.valid_tag);
		for (i1 = 0; i1 < ((sizeof(CRYSRSAPubKey_t)/sizeof(DxUint32_t) + 1)); i1++) {
				userPubKey_ptr->PublicKeyDbBuff[i1] = le32_to_cpu(params.__userPubKey_ptr.PublicKeyDbBuff[i1]);
		}
		params.__userPubKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* DX_RSA_KG_ExtendGenerateKeyPair */


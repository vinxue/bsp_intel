/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 12:33:37.093593 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file crys_kdf_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysKdf API */

#include <string.h>
#include "crys_kdf.h"
#include "crys_kdf_error.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_kdf_seprpc.h"


/************ _DX_KDF_KeyDerivFunc ***************/
CRYSError_t _DX_KDF_KeyDerivFunc(
	DxUint8_t ZZSecret_ptr[],
	DxUint32_t ZZSecretSize,
	CRYS_KDF_OtherInfo_t *OtherInfo_ptr,
	DxUint32_t KDFhashMode,
	DxUint32_t derivation_mode,
	DxUint8_t KeyingData_ptr[],
	DxUint32_t KeyingDataSizeBytes)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_KDF_KeyDerivFuncParams params;

	/* Verify input parameters and copy into params. struct. */
	if (ZZSecret_ptr == NULL) {
		params.ZZSecret_ptr_null_flag = 1;
	} else {
		/* Verify array size of ZZSecret_ptr */
		SEP_RPC_ASSERT((ZZSecretSize) <= (CRYS_KDF_MAX_SIZE_OF_SHARED_SECRET_VALUE), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.ZZSecret_ptr, ZZSecret_ptr, sizeof(DxUint8_t) * (ZZSecretSize));
		params.ZZSecret_ptr_null_flag = 0;
	}

	params.ZZSecretSize = cpu_to_le32(ZZSecretSize);
	if (OtherInfo_ptr == NULL) {
		params.__OtherInfo_ptr_null_flag = 1;
	} else {
		/* Verify array size of AlgorithmID */
		SEP_RPC_ASSERT((OtherInfo_ptr->SizeOfAlgorithmID) <= (CRYS_KDF_MAX_SIZE_OF_OTHER_INFO_ENTRY), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__OtherInfo_ptr.AlgorithmID, OtherInfo_ptr->AlgorithmID, sizeof(DxUint8_t) * (OtherInfo_ptr->SizeOfAlgorithmID));
		params.__OtherInfo_ptr.SizeOfAlgorithmID = cpu_to_le32(OtherInfo_ptr->SizeOfAlgorithmID);
		/* Verify array size of PartyUInfo */
		SEP_RPC_ASSERT((OtherInfo_ptr->SizeOfPartyUInfo) <= (CRYS_KDF_MAX_SIZE_OF_OTHER_INFO_ENTRY), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__OtherInfo_ptr.PartyUInfo, OtherInfo_ptr->PartyUInfo, sizeof(DxUint8_t) * (OtherInfo_ptr->SizeOfPartyUInfo));
		params.__OtherInfo_ptr.SizeOfPartyUInfo = cpu_to_le32(OtherInfo_ptr->SizeOfPartyUInfo);
		/* Verify array size of PartyVInfo */
		SEP_RPC_ASSERT((OtherInfo_ptr->SizeOfPartyVInfo) <= (CRYS_KDF_MAX_SIZE_OF_OTHER_INFO_ENTRY), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__OtherInfo_ptr.PartyVInfo, OtherInfo_ptr->PartyVInfo, sizeof(DxUint8_t) * (OtherInfo_ptr->SizeOfPartyVInfo));
		params.__OtherInfo_ptr.SizeOfPartyVInfo = cpu_to_le32(OtherInfo_ptr->SizeOfPartyVInfo);
		/* Verify array size of SuppPrivInfo */
		SEP_RPC_ASSERT((OtherInfo_ptr->SizeOfSuppPrivInfo) <= (CRYS_KDF_MAX_SIZE_OF_OTHER_INFO_ENTRY), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__OtherInfo_ptr.SuppPrivInfo, OtherInfo_ptr->SuppPrivInfo, sizeof(DxUint8_t) * (OtherInfo_ptr->SizeOfSuppPrivInfo));
		params.__OtherInfo_ptr.SizeOfSuppPrivInfo = cpu_to_le32(OtherInfo_ptr->SizeOfSuppPrivInfo);
		/* Verify array size of SuppPubInfo */
		SEP_RPC_ASSERT((OtherInfo_ptr->SizeOfSuppPubInfo) <= (CRYS_KDF_MAX_SIZE_OF_OTHER_INFO_ENTRY), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.__OtherInfo_ptr.SuppPubInfo, OtherInfo_ptr->SuppPubInfo, sizeof(DxUint8_t) * (OtherInfo_ptr->SizeOfSuppPubInfo));
		params.__OtherInfo_ptr.SizeOfSuppPubInfo = cpu_to_le32(OtherInfo_ptr->SizeOfSuppPubInfo);
		params.__OtherInfo_ptr_null_flag = 0;
	}

	params.KDFhashMode = cpu_to_le32(KDFhashMode);
	params.derivation_mode = cpu_to_le32(derivation_mode);
	params.KeyingDataSizeBytes = cpu_to_le32(KeyingDataSizeBytes);
	if (KeyingData_ptr == NULL) {
		params.KeyingData_ptr_null_flag = 1;
	} else {
		/* Verify array size of KeyingData_ptr */
		SEP_RPC_ASSERT((KeyingDataSizeBytes) <= (CRYS_KDF_MAX_SIZE_OF_KEYING_DATA), CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.KeyingData_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_KDF_KeyDerivFunc);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysKdf, SEPRPC_FUNC_ID__DX_KDF_KeyDerivFunc,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_KDF_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_KDF_KeyDerivFunc failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_KDF_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_KDF_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_KDF_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (KeyingData_ptr == NULL) {
		params.KeyingData_ptr_null_flag = 1;
	} else {
		memcpy(KeyingData_ptr, params.KeyingData_ptr, sizeof(DxUint8_t) * (KeyingDataSizeBytes));
		params.KeyingData_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_KDF_KeyDerivFunc */


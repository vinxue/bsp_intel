/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 11:56:58.512004 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file crys_ecc_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysEcc API */

#include <string.h>
#include "crys_host_rpc_config.h"
#include "crys_ecpki_error.h"
#include "crys_ecpki_build.h"
#include "crys_ecpki_types.h"
#include "crys_ecpki_ecdsa.h"
#include "crys_ecpki_elgamal.h"
#include "crys_ecpki_kg.h"
#include "crys_ecpki_dh.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_ecc_seprpc.h"


/************ CRYS_ECPKI_BuildPrivKey ***************/
CRYSError_t CRYS_ECPKI_BuildPrivKey(
	CRYS_ECPKI_DomainID_t DomainID,
	DxUint8_t PrivKeyIn_ptr[],
	DxUint32_t PrivKeySizeInBytes,
	CRYS_ECPKI_UserPrivKey_t *UserPrivKey_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECPKI_BuildPrivKeyParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DomainID = cpu_to_le32(DomainID);
	if (PrivKeyIn_ptr == NULL) {
		params.PrivKeyIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of PrivKeyIn_ptr */
		SEP_RPC_ASSERT((PrivKeySizeInBytes) <= (4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS+2), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.PrivKeyIn_ptr, PrivKeyIn_ptr, sizeof(DxUint8_t) * (PrivKeySizeInBytes));
		params.PrivKeyIn_ptr_null_flag = 0;
	}

	params.PrivKeySizeInBytes = cpu_to_le32(PrivKeySizeInBytes);
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECPKI_BuildPrivKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECPKI_BuildPrivKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECPKI_BuildPrivKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		memcpy(UserPrivKey_ptr->PrivKeyDbBuff, params.__UserPrivKey_ptr.PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__UserPrivKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECPKI_BuildPrivKey */



/************ _DX_ECPKI_BuildPublKey ***************/
CRYSError_t _DX_ECPKI_BuildPublKey(
	CRYS_ECPKI_DomainID_t DomainID,
	DxUint8_t PublKeyIn_ptr[],
	DxUint32_t PublKeySizeInBytes,
	EC_PublKeyCheckMode_t CheckMode,
	CRYS_ECPKI_UserPublKey_t *UserPublKey_ptr,
	CRYS_ECPKI_BUILD_TempData_t *TempBuff_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_ECPKI_BuildPublKeyParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DomainID = cpu_to_le32(DomainID);
	if (PublKeyIn_ptr == NULL) {
		params.PublKeyIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of PublKeyIn_ptr */
		SEP_RPC_ASSERT((PublKeySizeInBytes) <= (4*2*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS+2), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.PublKeyIn_ptr, PublKeyIn_ptr, sizeof(DxUint8_t) * (PublKeySizeInBytes));
		params.PublKeyIn_ptr_null_flag = 0;
	}

	params.PublKeySizeInBytes = cpu_to_le32(PublKeySizeInBytes);
	params.CheckMode = cpu_to_le32(CheckMode);
	params.TempBuff_ptr_size = cpu_to_le32((sizeof(CRYS_ECPKI_BUILD_TempData_t)));
	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		params.__UserPublKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_ECPKI_BuildPublKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID__DX_ECPKI_BuildPublKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_ECPKI_BuildPublKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		UserPublKey_ptr->valid_tag = le32_to_cpu(params.__UserPublKey_ptr.valid_tag);
		memcpy(UserPublKey_ptr->PublKeyDbBuff, params.__UserPublKey_ptr.PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__UserPublKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_ECPKI_BuildPublKey */



/************ CRYS_ECDSA_SignInit ***************/
CRYSError_t CRYS_ECDSA_SignInit(
	CRYS_ECDSA_SignUserContext_t *SignUserContext_ptr,
	CRYS_ECPKI_UserPrivKey_t *SignerPrivKey_ptr,
	CRYS_ECPKI_HASH_OpMode_t HashMode)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECDSA_SignInitParams params;

	/* Verify input parameters and copy into params. struct. */
	if (SignerPrivKey_ptr == NULL) {
		params.__SignerPrivKey_ptr_null_flag = 1;
	} else {
		params.__SignerPrivKey_ptr.valid_tag = cpu_to_le32(SignerPrivKey_ptr->valid_tag);
		memcpy(params.__SignerPrivKey_ptr.PrivKeyDbBuff, SignerPrivKey_ptr->PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__SignerPrivKey_ptr_null_flag = 0;
	}

	params.HashMode = cpu_to_le32(HashMode);
	if (SignUserContext_ptr == NULL) {
		params.__SignUserContext_ptr_null_flag = 1;
	} else {
		params.__SignUserContext_ptr.valid_tag = cpu_to_le32(SignUserContext_ptr->valid_tag);
		params.__SignUserContext_ptr.AES_iv = cpu_to_le32(SignUserContext_ptr->AES_iv);
		memcpy(params.__SignUserContext_ptr.context_buff, SignUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_SignContext_t)));
		params.__SignUserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_SignInit);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_SignInit,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_SignInit failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (SignUserContext_ptr == NULL) {
		params.__SignUserContext_ptr_null_flag = 1;
	} else {
		SignUserContext_ptr->valid_tag = le32_to_cpu(params.__SignUserContext_ptr.valid_tag);
		SignUserContext_ptr->AES_iv = le32_to_cpu(params.__SignUserContext_ptr.AES_iv);
		memcpy(SignUserContext_ptr->context_buff, params.__SignUserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_SignContext_t)));
		params.__SignUserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_SignInit */



/************ CRYS_ECDSA_SignUpdate ***************/
CRYSError_t CRYS_ECDSA_SignUpdate(
	CRYS_ECDSA_SignUserContext_t *SignUserContext_ptr,
	DxUint8_t *MessageDataIn_ptr,
	DxUint32_t DataInSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_ECDSA_SignUpdate];
	struct SepRpc_CRYS_ECDSA_SignUpdateParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DataInSize = cpu_to_le32(DataInSize);
	if (SignUserContext_ptr == NULL) {
		params.__SignUserContext_ptr_null_flag = 1;
	} else {
		params.__SignUserContext_ptr.valid_tag = cpu_to_le32(SignUserContext_ptr->valid_tag);
		params.__SignUserContext_ptr.AES_iv = cpu_to_le32(SignUserContext_ptr->AES_iv);
		memcpy(params.__SignUserContext_ptr.context_buff, SignUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_SignContext_t)));
		params.__SignUserContext_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* MessageDataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].start_or_offset = (unsigned long)MessageDataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_SignUpdate);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_SignUpdate,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_SignUpdate failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (SignUserContext_ptr == NULL) {
		params.__SignUserContext_ptr_null_flag = 1;
	} else {
		SignUserContext_ptr->valid_tag = le32_to_cpu(params.__SignUserContext_ptr.valid_tag);
		SignUserContext_ptr->AES_iv = le32_to_cpu(params.__SignUserContext_ptr.AES_iv);
		memcpy(SignUserContext_ptr->context_buff, params.__SignUserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_SignContext_t)));
		params.__SignUserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_SignUpdate */



/************ _DX_ECDSA_SignFinish ***************/
CRYSError_t _DX_ECDSA_SignFinish(
	CRYS_ECDSA_SignUserContext_t *SignUserContext_ptr,
	DxUint8_t SignatureOut_ptr[],
	DxUint32_t *SignatureOutSize_ptr,
	DxInt8_t IsEphemerKeyInternal,
	DxUint32_t EphemerKeyData_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_ECDSA_SignFinishParams params;

	/* Verify input parameters and copy into params. struct. */
	if (SignUserContext_ptr == NULL) {
		params.__SignUserContext_ptr_null_flag = 1;
	} else {
		params.__SignUserContext_ptr.valid_tag = cpu_to_le32(SignUserContext_ptr->valid_tag);
		params.__SignUserContext_ptr.AES_iv = cpu_to_le32(SignUserContext_ptr->AES_iv);
		memcpy(params.__SignUserContext_ptr.context_buff, SignUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_SignContext_t)));
		params.__SignUserContext_ptr_null_flag = 0;
	}

	params.IsEphemerKeyInternal = IsEphemerKeyInternal;
	if (EphemerKeyData_ptr == NULL) {
		params.EphemerKeyData_ptr_null_flag = 1;
	} else {
		memcpy(params.EphemerKeyData_ptr, EphemerKeyData_ptr, sizeof(DxUint32_t) * (4*(CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS+1)+2*4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS));
		params.EphemerKeyData_ptr_null_flag = 0;
	}

	if (SignatureOutSize_ptr == NULL) {
		params.__SignatureOutSize_ptr_null_flag = 1;
	} else {
		params.__SignatureOutSize_ptr = cpu_to_le32(*(SignatureOutSize_ptr));
		params.__SignatureOutSize_ptr_null_flag = 0;
	}

	if (SignatureOut_ptr == NULL) {
		params.SignatureOut_ptr_null_flag = 1;
    } else if (SignatureOutSize_ptr != NULL) {
		/* Verify array size of SignatureOut_ptr */
		SEP_RPC_ASSERT((*SignatureOutSize_ptr) <= (4*2*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS+2), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.SignatureOut_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_ECDSA_SignFinish);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID__DX_ECDSA_SignFinish,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_ECDSA_SignFinish failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (SignatureOutSize_ptr == NULL) {
		params.__SignatureOutSize_ptr_null_flag = 1;
	} else {
		*(SignatureOutSize_ptr) = le32_to_cpu(params.__SignatureOutSize_ptr);
		params.__SignatureOutSize_ptr_null_flag = 0;
	}

	if (SignatureOut_ptr == NULL) {
		params.SignatureOut_ptr_null_flag = 1;
    } else if (SignatureOutSize_ptr != NULL) {
		memcpy(SignatureOut_ptr, params.SignatureOut_ptr, sizeof(DxUint8_t) * (*SignatureOutSize_ptr));
		params.SignatureOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_ECDSA_SignFinish */



/************ CRYS_ECDSA_Sign ***************/
CRYSError_t CRYS_ECDSA_Sign(
	CRYS_ECDSA_SignUserContext_t *SignUserContext_ptr,
	CRYS_ECPKI_UserPrivKey_t *SignerPrivKey_ptr,
	CRYS_ECPKI_HASH_OpMode_t HashMode,
	DxUint8_t *MessageDataIn_ptr,
	DxUint32_t MessageSizeInBytes,
	DxUint8_t SignatureOut_ptr[],
	DxUint32_t *SignatureOutSize_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_ECDSA_Sign];
	struct SepRpc_CRYS_ECDSA_SignParams params;

	/* Verify input parameters and copy into params. struct. */
	params.SignUserContext_ptr_size = cpu_to_le32((sizeof(CRYS_ECDSA_SignUserContext_t)));
	if (SignerPrivKey_ptr == NULL) {
		params.__SignerPrivKey_ptr_null_flag = 1;
	} else {
		params.__SignerPrivKey_ptr.valid_tag = cpu_to_le32(SignerPrivKey_ptr->valid_tag);
		memcpy(params.__SignerPrivKey_ptr.PrivKeyDbBuff, SignerPrivKey_ptr->PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__SignerPrivKey_ptr_null_flag = 0;
	}

	params.HashMode = cpu_to_le32(HashMode);
	params.MessageSizeInBytes = cpu_to_le32(MessageSizeInBytes);
	if (SignatureOutSize_ptr == NULL) {
		params.__SignatureOutSize_ptr_null_flag = 1;
	} else {
		params.__SignatureOutSize_ptr = cpu_to_le32(*(SignatureOutSize_ptr));
		params.__SignatureOutSize_ptr_null_flag = 0;
	}

	if (SignatureOut_ptr == NULL) {
		params.SignatureOut_ptr_null_flag = 1;
    } else if (SignatureOutSize_ptr != NULL) {
		/* Verify array size of SignatureOut_ptr */
		SEP_RPC_ASSERT(((*SignatureOutSize_ptr)) <= (4*2*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS+2), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.SignatureOut_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* MessageDataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].start_or_offset = (unsigned long)MessageDataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].size = MessageSizeInBytes;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_Sign);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_Sign,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_Sign failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (SignatureOutSize_ptr == NULL) {
		params.__SignatureOutSize_ptr_null_flag = 1;
	} else {
		*(SignatureOutSize_ptr) = le32_to_cpu(params.__SignatureOutSize_ptr);
		params.__SignatureOutSize_ptr_null_flag = 0;
	}

	if (SignatureOut_ptr == NULL) {
		params.SignatureOut_ptr_null_flag = 1;
    } else if (SignatureOutSize_ptr != NULL) {
		memcpy(SignatureOut_ptr, params.SignatureOut_ptr, sizeof(DxUint8_t) * ((*SignatureOutSize_ptr)));
		params.SignatureOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_Sign */



/************ CRYS_ECDSA_VerifyInit ***************/
CRYSError_t CRYS_ECDSA_VerifyInit(
	CRYS_ECDSA_VerifyUserContext_t *VerifyUserContext_ptr,
	CRYS_ECPKI_UserPublKey_t *SignerPublKey_ptr,
	CRYS_ECPKI_HASH_OpMode_t HashMode)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECDSA_VerifyInitParams params;

	/* Verify input parameters and copy into params. struct. */
	if (SignerPublKey_ptr == NULL) {
		params.__SignerPublKey_ptr_null_flag = 1;
	} else {
		params.__SignerPublKey_ptr.valid_tag = cpu_to_le32(SignerPublKey_ptr->valid_tag);
		memcpy(params.__SignerPublKey_ptr.PublKeyDbBuff, SignerPublKey_ptr->PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__SignerPublKey_ptr_null_flag = 0;
	}

	params.HashMode = cpu_to_le32(HashMode);
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		params.__VerifyUserContext_ptr.valid_tag = cpu_to_le32(VerifyUserContext_ptr->valid_tag);
		params.__VerifyUserContext_ptr.AES_iv = cpu_to_le32(VerifyUserContext_ptr->AES_iv);
		memcpy(params.__VerifyUserContext_ptr.context_buff, VerifyUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_VerifyInit);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_VerifyInit,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_VerifyInit failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		VerifyUserContext_ptr->valid_tag = le32_to_cpu(params.__VerifyUserContext_ptr.valid_tag);
		VerifyUserContext_ptr->AES_iv = le32_to_cpu(params.__VerifyUserContext_ptr.AES_iv);
		memcpy(VerifyUserContext_ptr->context_buff, params.__VerifyUserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_VerifyInit */



/************ CRYS_ECDSA_VerifyUpdate ***************/
CRYSError_t CRYS_ECDSA_VerifyUpdate(
	CRYS_ECDSA_VerifyUserContext_t *VerifyUserContext_ptr,
	DxUint8_t *MessageDataIn_ptr,
	DxUint32_t DataInSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_ECDSA_VerifyUpdate];
	struct SepRpc_CRYS_ECDSA_VerifyUpdateParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DataInSize = cpu_to_le32(DataInSize);
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		params.__VerifyUserContext_ptr.valid_tag = cpu_to_le32(VerifyUserContext_ptr->valid_tag);
		params.__VerifyUserContext_ptr.AES_iv = cpu_to_le32(VerifyUserContext_ptr->AES_iv);
		memcpy(params.__VerifyUserContext_ptr.context_buff, VerifyUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* MessageDataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].start_or_offset = (unsigned long)MessageDataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_VerifyUpdate);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_VerifyUpdate,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_VerifyUpdate failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		VerifyUserContext_ptr->valid_tag = le32_to_cpu(params.__VerifyUserContext_ptr.valid_tag);
		VerifyUserContext_ptr->AES_iv = le32_to_cpu(params.__VerifyUserContext_ptr.AES_iv);
		memcpy(VerifyUserContext_ptr->context_buff, params.__VerifyUserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_VerifyUpdate */



/************ CRYS_ECDSA_VerifyFinish ***************/
CRYSError_t CRYS_ECDSA_VerifyFinish(
	CRYS_ECDSA_VerifyUserContext_t *VerifyUserContext_ptr,
	DxUint8_t SignatureIn_ptr[],
	DxUint32_t SignatureSizeBytes)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECDSA_VerifyFinishParams params;

	/* Verify input parameters and copy into params. struct. */
	if (SignatureIn_ptr == NULL) {
		params.SignatureIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of SignatureIn_ptr */
		SEP_RPC_ASSERT((SignatureSizeBytes) <= (4*2*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.SignatureIn_ptr, SignatureIn_ptr, sizeof(DxUint8_t) * (SignatureSizeBytes));
		params.SignatureIn_ptr_null_flag = 0;
	}

	params.SignatureSizeBytes = cpu_to_le32(SignatureSizeBytes);
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		params.__VerifyUserContext_ptr.valid_tag = cpu_to_le32(VerifyUserContext_ptr->valid_tag);
		params.__VerifyUserContext_ptr.AES_iv = cpu_to_le32(VerifyUserContext_ptr->AES_iv);
		memcpy(params.__VerifyUserContext_ptr.context_buff, VerifyUserContext_ptr->context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_VerifyFinish);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_VerifyFinish,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_VerifyFinish failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (VerifyUserContext_ptr == NULL) {
		params.__VerifyUserContext_ptr_null_flag = 1;
	} else {
		VerifyUserContext_ptr->valid_tag = le32_to_cpu(params.__VerifyUserContext_ptr.valid_tag);
		VerifyUserContext_ptr->AES_iv = le32_to_cpu(params.__VerifyUserContext_ptr.AES_iv);
		memcpy(VerifyUserContext_ptr->context_buff, params.__VerifyUserContext_ptr.context_buff, sizeof(DxUint8_t) * (sizeof(ECDSA_VerifyContext_t)));
		params.__VerifyUserContext_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_VerifyFinish */



/************ CRYS_ECDSA_Verify ***************/
CRYSError_t CRYS_ECDSA_Verify(
	CRYS_ECDSA_VerifyUserContext_t *VerifyUserContext_ptr,
	CRYS_ECPKI_UserPublKey_t *UserPublKey_ptr,
	CRYS_ECPKI_HASH_OpMode_t HashMode,
	DxUint8_t SignatureIn_ptr[],
	DxUint32_t SignatureSizeBytes,
	DxUint8_t *MessageDataIn_ptr,
	DxUint32_t MessageSizeInBytes)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_ECDSA_Verify];
	struct SepRpc_CRYS_ECDSA_VerifyParams params;

	/* Verify input parameters and copy into params. struct. */
	params.VerifyUserContext_ptr_size = cpu_to_le32((sizeof(CRYS_ECDSA_VerifyUserContext_t)));
	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		params.__UserPublKey_ptr.valid_tag = cpu_to_le32(UserPublKey_ptr->valid_tag);
		memcpy(params.__UserPublKey_ptr.PublKeyDbBuff, UserPublKey_ptr->PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__UserPublKey_ptr_null_flag = 0;
	}

	params.HashMode = cpu_to_le32(HashMode);
	if (SignatureIn_ptr == NULL) {
		params.SignatureIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of SignatureIn_ptr */
		SEP_RPC_ASSERT((SignatureSizeBytes) <= (4*2*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.SignatureIn_ptr, SignatureIn_ptr, sizeof(DxUint8_t) * (SignatureSizeBytes));
		params.SignatureIn_ptr_null_flag = 0;
	}

	params.SignatureSizeBytes = cpu_to_le32(SignatureSizeBytes);
	params.MessageSizeInBytes = cpu_to_le32(MessageSizeInBytes);

	/* User DMA buffers (memory references) */
	/* MessageDataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].start_or_offset = (unsigned long)MessageDataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].size = MessageSizeInBytes;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_MessageDataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDSA_Verify);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDSA_Verify,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDSA_Verify failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDSA_Verify */



/************ _DX_ECPKI_ELGAMAL_Encrypt ***************/
CRYSError_t _DX_ECPKI_ELGAMAL_Encrypt(
	CRYS_ECPKI_UserPublKey_t *ReceiverUserPublKey_ptr,
	DxUint8_t MessageIn_ptr[],
	DxUint32_t MessageInSizeBytes,
	DxUint8_t EncrMessageOut_ptr[],
	DxUint32_t *EncrMessOutSize_ptr,
	DxInt8_t IsEphemerKeyInternal,
	DxUint8_t EphemerPrivKeyIn_ptr[],
	DxUint32_t EphemerPrivKeySizeBytes,
	CRYS_EC_ELGAMAL_TempData_t *TempData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc__DX_ECPKI_ELGAMAL_EncryptParams params;

	/* Verify input parameters and copy into params. struct. */
	if (ReceiverUserPublKey_ptr == NULL) {
		params.__ReceiverUserPublKey_ptr_null_flag = 1;
	} else {
		params.__ReceiverUserPublKey_ptr.valid_tag = cpu_to_le32(ReceiverUserPublKey_ptr->valid_tag);
		memcpy(params.__ReceiverUserPublKey_ptr.PublKeyDbBuff, ReceiverUserPublKey_ptr->PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__ReceiverUserPublKey_ptr_null_flag = 0;
	}

	if (MessageIn_ptr == NULL) {
		params.MessageIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of MessageIn_ptr */
		SEP_RPC_ASSERT((MessageInSizeBytes) <= (4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.MessageIn_ptr, MessageIn_ptr, sizeof(DxUint8_t) * (MessageInSizeBytes));
		params.MessageIn_ptr_null_flag = 0;
	}

	params.MessageInSizeBytes = cpu_to_le32(MessageInSizeBytes);
	params.IsEphemerKeyInternal = IsEphemerKeyInternal;
	if (EphemerPrivKeyIn_ptr == NULL) {
		params.EphemerPrivKeyIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of EphemerPrivKeyIn_ptr */
		SEP_RPC_ASSERT((EphemerPrivKeySizeBytes) <= (4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.EphemerPrivKeyIn_ptr, EphemerPrivKeyIn_ptr, sizeof(DxUint8_t) * (EphemerPrivKeySizeBytes));
		params.EphemerPrivKeyIn_ptr_null_flag = 0;
	}

	params.EphemerPrivKeySizeBytes = cpu_to_le32(EphemerPrivKeySizeBytes);
	if (TempData_ptr == NULL) {
		params.__TempData_ptr_null_flag = 1;
	} else {
		params.__TempData_ptr = *(TempData_ptr);
		params.__TempData_ptr_null_flag = 0;
	}

	if (EncrMessOutSize_ptr == NULL) {
		params.__EncrMessOutSize_ptr_null_flag = 1;
	} else {
		params.__EncrMessOutSize_ptr = cpu_to_le32(*(EncrMessOutSize_ptr));
		params.__EncrMessOutSize_ptr_null_flag = 0;
	}

	if (EncrMessageOut_ptr == NULL) {
		params.EncrMessageOut_ptr_null_flag = 1;
    } else if (EncrMessOutSize_ptr != NULL) {
		/* Verify array size of EncrMessageOut_ptr */
		SEP_RPC_ASSERT((*EncrMessOutSize_ptr) <= (4*4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.EncrMessageOut_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM__DX_ECPKI_ELGAMAL_Encrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID__DX_ECPKI_ELGAMAL_Encrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of _DX_ECPKI_ELGAMAL_Encrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (EncrMessOutSize_ptr == NULL) {
		params.__EncrMessOutSize_ptr_null_flag = 1;
	} else {
		*(EncrMessOutSize_ptr) = le32_to_cpu(params.__EncrMessOutSize_ptr);
		params.__EncrMessOutSize_ptr_null_flag = 0;
	}

	if (EncrMessageOut_ptr == NULL) {
		params.EncrMessageOut_ptr_null_flag = 1;
    } else if (EncrMessOutSize_ptr != NULL) {
		memcpy(EncrMessageOut_ptr, params.EncrMessageOut_ptr, sizeof(DxUint8_t) * (*EncrMessOutSize_ptr));
		params.EncrMessageOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* _DX_ECPKI_ELGAMAL_Encrypt */



/************ CRYS_ECPKI_ELGAMAL_Decrypt ***************/
CRYSError_t CRYS_ECPKI_ELGAMAL_Decrypt(
	CRYS_ECPKI_UserPrivKey_t *ReceiverUserPrivKey_ptr,
	DxUint8_t EncrMessageIn_ptr[],
	DxUint32_t EncrMessageSizeInBytes,
	DxUint8_t DecrMessageOut_ptr[],
	DxUint32_t *DecrMessageOutSize_ptr,
	CRYS_EC_ELGAMAL_TempData_t *TempData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECPKI_ELGAMAL_DecryptParams params;

	/* Verify input parameters and copy into params. struct. */
	if (ReceiverUserPrivKey_ptr == NULL) {
		params.__ReceiverUserPrivKey_ptr_null_flag = 1;
	} else {
		params.__ReceiverUserPrivKey_ptr.valid_tag = cpu_to_le32(ReceiverUserPrivKey_ptr->valid_tag);
		memcpy(params.__ReceiverUserPrivKey_ptr.PrivKeyDbBuff, ReceiverUserPrivKey_ptr->PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__ReceiverUserPrivKey_ptr_null_flag = 0;
	}

	if (EncrMessageIn_ptr == NULL) {
		params.EncrMessageIn_ptr_null_flag = 1;
	} else {
		/* Verify array size of EncrMessageIn_ptr */
		SEP_RPC_ASSERT((EncrMessageSizeInBytes) <= (4*4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		memcpy(params.EncrMessageIn_ptr, EncrMessageIn_ptr, sizeof(DxUint8_t) * (EncrMessageSizeInBytes));
		params.EncrMessageIn_ptr_null_flag = 0;
	}

	params.EncrMessageSizeInBytes = cpu_to_le32(EncrMessageSizeInBytes);
	params.TempData_ptr_size = cpu_to_le32((sizeof(CRYS_EC_ELGAMAL_TempData_t)));
	if (DecrMessageOutSize_ptr == NULL) {
		params.__DecrMessageOutSize_ptr_null_flag = 1;
	} else {
		params.__DecrMessageOutSize_ptr = cpu_to_le32(*(DecrMessageOutSize_ptr));
		params.__DecrMessageOutSize_ptr_null_flag = 0;
	}

	if (DecrMessageOut_ptr == NULL) {
		params.DecrMessageOut_ptr_null_flag = 1;
    } else if (DecrMessageOutSize_ptr != NULL) {
		/* Verify array size of DecrMessageOut_ptr */
		SEP_RPC_ASSERT((*DecrMessageOutSize_ptr) <= (4*4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.DecrMessageOut_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECPKI_ELGAMAL_Decrypt);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECPKI_ELGAMAL_Decrypt,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECPKI_ELGAMAL_Decrypt failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (DecrMessageOutSize_ptr == NULL) {
		params.__DecrMessageOutSize_ptr_null_flag = 1;
	} else {
		*(DecrMessageOutSize_ptr) = le32_to_cpu(params.__DecrMessageOutSize_ptr);
		params.__DecrMessageOutSize_ptr_null_flag = 0;
	}

	if (DecrMessageOut_ptr == NULL) {
		params.DecrMessageOut_ptr_null_flag = 1;
    } else if (DecrMessageOutSize_ptr != NULL) {
		memcpy(DecrMessageOut_ptr, params.DecrMessageOut_ptr, sizeof(DxUint8_t) * (*DecrMessageOutSize_ptr));
		params.DecrMessageOut_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECPKI_ELGAMAL_Decrypt */



/************ CRYS_ECDH_SVDP_DH ***************/
CRYSError_t CRYS_ECDH_SVDP_DH(
	CRYS_ECPKI_UserPublKey_t *PartnerPublKey_ptr,
	CRYS_ECPKI_UserPrivKey_t *UserPrivKey_ptr,
	DxUint8_t SharedSecretValue_ptr[],
	DxUint32_t *SharedSecrValSize_ptr,
	CRYS_ECDH_TempData_t *TempBuff_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECDH_SVDP_DHParams params;

	/* Verify input parameters and copy into params. struct. */
	if (PartnerPublKey_ptr == NULL) {
		params.__PartnerPublKey_ptr_null_flag = 1;
	} else {
		params.__PartnerPublKey_ptr.valid_tag = cpu_to_le32(PartnerPublKey_ptr->valid_tag);
		memcpy(params.__PartnerPublKey_ptr.PublKeyDbBuff, PartnerPublKey_ptr->PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__PartnerPublKey_ptr_null_flag = 0;
	}

	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr.valid_tag = cpu_to_le32(UserPrivKey_ptr->valid_tag);
		memcpy(params.__UserPrivKey_ptr.PrivKeyDbBuff, UserPrivKey_ptr->PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	params.TempBuff_ptr_size = cpu_to_le32((sizeof(CRYS_ECDH_TempData_t)));
	if (SharedSecrValSize_ptr == NULL) {
		params.__SharedSecrValSize_ptr_null_flag = 1;
	} else {
		params.__SharedSecrValSize_ptr = cpu_to_le32(*(SharedSecrValSize_ptr));
		params.__SharedSecrValSize_ptr_null_flag = 0;
	}

	if (SharedSecretValue_ptr == NULL) {
		params.SharedSecretValue_ptr_null_flag = 1;
    } else if (SharedSecrValSize_ptr != NULL) {
		/* Verify array size of SharedSecretValue_ptr */
		SEP_RPC_ASSERT((*SharedSecrValSize_ptr) <= (4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.SharedSecretValue_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECDH_SVDP_DH);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECDH_SVDP_DH,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECDH_SVDP_DH failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (SharedSecrValSize_ptr == NULL) {
		params.__SharedSecrValSize_ptr_null_flag = 1;
	} else {
		*(SharedSecrValSize_ptr) = le32_to_cpu(params.__SharedSecrValSize_ptr);
		params.__SharedSecrValSize_ptr_null_flag = 0;
	}

	if (SharedSecretValue_ptr == NULL) {
		params.SharedSecretValue_ptr_null_flag = 1;
    } else if (SharedSecrValSize_ptr != NULL) {
		memcpy(SharedSecretValue_ptr, params.SharedSecretValue_ptr, sizeof(DxUint8_t) * (*SharedSecrValSize_ptr));
		params.SharedSecretValue_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECDH_SVDP_DH */



/************ CRYS_ECPKI_ExportPublKey ***************/
CRYSError_t CRYS_ECPKI_ExportPublKey(
	CRYS_ECPKI_UserPublKey_t *UserPublKey_ptr,
	CRYS_ECPKI_PointCompression_t Compression,
	DxUint8_t ExternPublKey_ptr[],
	DxUint32_t *PublKeySizeInBytes_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECPKI_ExportPublKeyParams params;

	/* Verify input parameters and copy into params. struct. */
	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		params.__UserPublKey_ptr.valid_tag = cpu_to_le32(UserPublKey_ptr->valid_tag);
		memcpy(params.__UserPublKey_ptr.PublKeyDbBuff, UserPublKey_ptr->PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__UserPublKey_ptr_null_flag = 0;
	}

	params.Compression = cpu_to_le32(Compression);
	if (PublKeySizeInBytes_ptr == NULL) {
		params.__PublKeySizeInBytes_ptr_null_flag = 1;
	} else {
		params.__PublKeySizeInBytes_ptr = cpu_to_le32(*(PublKeySizeInBytes_ptr));
		params.__PublKeySizeInBytes_ptr_null_flag = 0;
	}

	if (ExternPublKey_ptr == NULL) {
		params.ExternPublKey_ptr_null_flag = 1;
    } else if (PublKeySizeInBytes_ptr != NULL) {
		/* Verify array size of ExternPublKey_ptr */
		SEP_RPC_ASSERT((*PublKeySizeInBytes_ptr) <= (4*CRYS_ECPKI_MODUL_MAX_LENGTH_IN_WORDS*2+1), CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR);
		params.ExternPublKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECPKI_ExportPublKey);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECPKI_ExportPublKey,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECPKI_ExportPublKey failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (PublKeySizeInBytes_ptr == NULL) {
		params.__PublKeySizeInBytes_ptr_null_flag = 1;
	} else {
		*(PublKeySizeInBytes_ptr) = le32_to_cpu(params.__PublKeySizeInBytes_ptr);
		params.__PublKeySizeInBytes_ptr_null_flag = 0;
	}

	if (ExternPublKey_ptr == NULL) {
		params.ExternPublKey_ptr_null_flag = 1;
    } else if (PublKeySizeInBytes_ptr != NULL) {
		memcpy(ExternPublKey_ptr, params.ExternPublKey_ptr, sizeof(DxUint8_t) * (*PublKeySizeInBytes_ptr));
		params.ExternPublKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECPKI_ExportPublKey */



/************ CRYS_ECPKI_GenKeyPair ***************/
CRYSError_t CRYS_ECPKI_GenKeyPair(
	CRYS_ECPKI_DomainID_t DomainID,
	CRYS_ECPKI_UserPrivKey_t *UserPrivKey_ptr,
	CRYS_ECPKI_UserPublKey_t *UserPublKey_ptr,
	CRYS_ECPKI_KG_TempData_t *TempData_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_ECPKI_GenKeyPairParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DomainID = cpu_to_le32(DomainID);
	params.TempData_ptr_size = cpu_to_le32((sizeof(CRYS_ECPKI_KG_TempData_t)));
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		params.__UserPublKey_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_ECPKI_GenKeyPair);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysEcc, SEPRPC_FUNC_ID_CRYS_ECPKI_GenKeyPair,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_ECPKI_GenKeyPair failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_C_ERROR;
		default:
			return CRYS_ECC_HOST_MSG_GENERAL_RPC_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (UserPrivKey_ptr == NULL) {
		params.__UserPrivKey_ptr_null_flag = 1;
	} else {
		UserPrivKey_ptr->valid_tag = le32_to_cpu(params.__UserPrivKey_ptr.valid_tag);
		memcpy(UserPrivKey_ptr->PrivKeyDbBuff, params.__UserPrivKey_ptr.PrivKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PrivKey_t)));
		params.__UserPrivKey_ptr_null_flag = 0;
	}

	if (UserPublKey_ptr == NULL) {
		params.__UserPublKey_ptr_null_flag = 1;
	} else {
		UserPublKey_ptr->valid_tag = le32_to_cpu(params.__UserPublKey_ptr.valid_tag);
		memcpy(UserPublKey_ptr->PublKeyDbBuff, params.__UserPublKey_ptr.PublKeyDbBuff, sizeof(DxUint8_t) * (sizeof(CRYS_ECPKI_PublKey_t)));
		params.__UserPublKey_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_ECPKI_GenKeyPair */


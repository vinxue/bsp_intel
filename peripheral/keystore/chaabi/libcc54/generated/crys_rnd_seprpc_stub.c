/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@2451 at 2012-09-20 11:57:50.780740 */
/*******************************************************************
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This file is licensed under the terms provided in the file       *
* libcc54/LICENSE in this directory or a parent directory          *
********************************************************************/

/* \file crys_rnd_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysRnd API */

#include <string.h>
#include "crys_rnd_error.h"
#include "crys_rnd.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_rnd_seprpc.h"


/************ CRYS_RND_Instantiation ***************/
CRYSError_t CRYS_RND_Instantiation(
	CRYS_RND_EntropyEstimatData_t *entrEstimBuff_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_InstantiationParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (entrEstimBuff_ptr == NULL) {
		params.__entrEstimBuff_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (CRYS_PKA_RND_ENTR_ESTIM_BUFF_MAX_LENGTH_IN_WORDS); i1++) {
				params.__entrEstimBuff_ptr.crysRndEntrIntBuff[i1] = cpu_to_le32(entrEstimBuff_ptr->crysRndEntrIntBuff[i1]);
		}
		params.__entrEstimBuff_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_Instantiation);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_Instantiation,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_Instantiation failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (entrEstimBuff_ptr == NULL) {
		params.__entrEstimBuff_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (CRYS_PKA_RND_ENTR_ESTIM_BUFF_MAX_LENGTH_IN_WORDS); i1++) {
				entrEstimBuff_ptr->crysRndEntrIntBuff[i1] = le32_to_cpu(params.__entrEstimBuff_ptr.crysRndEntrIntBuff[i1]);
		}
		params.__entrEstimBuff_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_Instantiation */



/************ CRYS_RND_Reseeding ***************/
CRYSError_t CRYS_RND_Reseeding(
	CRYS_RND_EntropyEstimatData_t *entrEstimBuff_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_ReseedingParams params;
	unsigned int i1;

	/* Verify input parameters and copy into params. struct. */
	if (entrEstimBuff_ptr == NULL) {
		params.__entrEstimBuff_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (CRYS_PKA_RND_ENTR_ESTIM_BUFF_MAX_LENGTH_IN_WORDS); i1++) {
				params.__entrEstimBuff_ptr.crysRndEntrIntBuff[i1] = cpu_to_le32(entrEstimBuff_ptr->crysRndEntrIntBuff[i1]);
		}
		params.__entrEstimBuff_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_Reseeding);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_Reseeding,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_Reseeding failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (entrEstimBuff_ptr == NULL) {
		params.__entrEstimBuff_ptr_null_flag = 1;
	} else {
		for (i1 = 0; i1 < (CRYS_PKA_RND_ENTR_ESTIM_BUFF_MAX_LENGTH_IN_WORDS); i1++) {
				entrEstimBuff_ptr->crysRndEntrIntBuff[i1] = le32_to_cpu(params.__entrEstimBuff_ptr.crysRndEntrIntBuff[i1]);
		}
		params.__entrEstimBuff_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_Reseeding */



/************ CRYS_RND_GenerateVector ***************/
CRYSError_t CRYS_RND_GenerateVector(
	DxUint16_t RndSize,
	DxUint8_t Output_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_GenerateVectorParams params;

	/* Verify input parameters and copy into params. struct. */
	params.RndSize = cpu_to_le16(RndSize);
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
	} else {
		/* Verify array size of Output_ptr */
		SEP_RPC_ASSERT((RndSize) <= (CRYS_RND_MAX_SIZE_OF_OUTPUT_BYTES), CRYS_RND_GEN_B_ERROR);
		params.Output_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_GenerateVector);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_GenerateVector,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_GenerateVector failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (Output_ptr == NULL) {
		params.Output_ptr_null_flag = 1;
    } else if (RndSize <= (sizeof(params.Output_ptr) / sizeof(params.Output_ptr[0]))) {
		memcpy(Output_ptr, params.Output_ptr, sizeof(DxUint8_t) * (RndSize));
		params.Output_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_GenerateVector */



/************ CRYS_RND_GenerateVectorInRange ***************/
CRYSError_t CRYS_RND_GenerateVectorInRange(
	DxUint32_t RndSizeInBits,
	DxUint8_t MaxVect_ptr[],
	DxUint8_t RndVect_ptr[])
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_GenerateVectorInRangeParams params;

	/* Verify input parameters and copy into params. struct. */
	params.RndSizeInBits = cpu_to_le32(RndSizeInBits);
	if (MaxVect_ptr == NULL) {
		params.MaxVect_ptr_null_flag = 1;
	} else {
		memcpy(params.MaxVect_ptr, MaxVect_ptr, sizeof(DxUint8_t) * (CRYS_RND_MAX_SIZE_OF_OUTPUT_BYTES));
		params.MaxVect_ptr_null_flag = 0;
	}

	if (RndVect_ptr == NULL) {
		params.RndVect_ptr_null_flag = 1;
	} else {
		/* Verify array size of RndVect_ptr */
		SEP_RPC_ASSERT(((RndSizeInBits+7)/8) <= (CRYS_RND_MAX_SIZE_OF_OUTPUT_BYTES), CRYS_RND_GEN_B_ERROR);
		params.RndVect_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_GenerateVectorInRange);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_GenerateVectorInRange,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_GenerateVectorInRange failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	/* Copy back output parameters */
	if (RndVect_ptr == NULL) {
		params.RndVect_ptr_null_flag = 1;
	} else {
		memcpy(RndVect_ptr, params.RndVect_ptr, sizeof(DxUint8_t) * ((RndSizeInBits+7)/8));
		params.RndVect_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_GenerateVectorInRange */



/************ CRYS_RND_AddAdditionalInput ***************/
CRYSError_t CRYS_RND_AddAdditionalInput(
	DxUint8_t AdditonalInput_ptr[],
	DxUint16_t AdditonalInputSize)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_AddAdditionalInputParams params;

	/* Verify input parameters and copy into params. struct. */
	if (AdditonalInput_ptr == NULL) {
		params.AdditonalInput_ptr_null_flag = 1;
	} else {
		/* Verify array size of AdditonalInput_ptr */
		SEP_RPC_ASSERT((AdditonalInputSize) <= (32), CRYS_RND_GEN_B_ERROR);
		memcpy(params.AdditonalInput_ptr, AdditonalInput_ptr, sizeof(DxUint8_t) * (AdditonalInputSize));
		params.AdditonalInput_ptr_null_flag = 0;
	}

	params.AdditonalInputSize = cpu_to_le16(AdditonalInputSize);

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_AddAdditionalInput);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_AddAdditionalInput,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_AddAdditionalInput failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_AddAdditionalInput */



/************ CRYS_RND_UnInstantiation ***************/
CRYSError_t CRYS_RND_UnInstantiation(
)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RND_UnInstantiationParams params;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RND_UnInstantiation);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRnd, SEPRPC_FUNC_ID_CRYS_RND_UnInstantiation,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RND_GEN_A_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RND_UnInstantiation failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RND_GEN_B_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RND_GEN_C_ERROR;
		default:
			return CRYS_RND_GEN_A_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RND_UnInstantiation */

